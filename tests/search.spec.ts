import path from 'path';
import fs from 'fs';
import { search } from '../dist';

const FIXTURES_DIR = path.join(__dirname, '__fixtures__');
const STRESS_DIR = path.join(FIXTURES_DIR, 'stress');

function rimrafDir(dir: string) {
  if (!fs.existsSync(dir)) return;
  const entries = fs.readdirSync(dir);
  for (const entry of entries) {
    const full = path.join(dir, entry);
    const stat = fs.lstatSync(full);
    if (stat.isDirectory()) rimrafDir(full);
    else fs.unlinkSync(full);
  }
  fs.rmdirSync(dir);
}

function ensureDir(dir: string) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function makeFileContent(callsPerFile: number): string {
  const lines: string[] = [];
  lines.push('/* autogenerated stress fixture */');
  lines.push('export const noop = () => {};');
  for (let i = 0; i < callsPerFile; i++) {
    const fnName = `fn${i}`;
    lines.push(`function ${fnName}(){ return ${i}; }`);
  }
  // Emit calls as separate lines to make counting simple
  for (let i = 0; i < callsPerFile; i++) {
    const fnName = `fn${i}`;
    lines.push(`${fnName}();`);
  }
  return lines.join('\n');
}

// Uncomment this for stress testing
describe.skip('search stress test', () => {
  jest.setTimeout(600000); // up to 10 minutes
  it('creates 50000 files with 100 CallExpression each and times search', async () => {
    const NUM_FILES = 50000;
    const CALLS_PER_FILE = 100;

    // Prepare fixtures
    ensureDir(FIXTURES_DIR);
    // Recreate stress dir fresh
    rimrafDir(STRESS_DIR);
    ensureDir(STRESS_DIR);
    const content = makeFileContent(CALLS_PER_FILE);
    // Write files synchronously to avoid EMFILE issues
    for (let i = 0; i < NUM_FILES; i++) {
      const f = path.join(STRESS_DIR, `file_${i}.ts`);
      fs.writeFileSync(f, content, 'utf-8');
    }
    const expectedMatches = NUM_FILES * CALLS_PER_FILE;
    const start = Date.now();
    let matches = 0;
    await search(
      'CallExpression',
      chunk => {
        console.log(`Chunk Size: ${chunk.length}`);
        matches += chunk.length;
      },
      { gitignore: true, directories: [STRESS_DIR], interval: 1000 }
    );
    const durationMs = Date.now() - start;
    console.log(`Found ${matches} CallExpression in ${durationMs} ms across ${NUM_FILES} files.`);
    expect(matches).toBe(expectedMatches);
    rimrafDir(STRESS_DIR);
  });
});
