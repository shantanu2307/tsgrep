import path from 'path';
import fs from 'fs';
import { search, cleanup, SearchResult } from '../dist';

const FIXTURES_DIR = path.join(__dirname, '__fixtures__');
const STRESS_DIR = path.join(FIXTURES_DIR, 'stress');

function rimrafDir(dir: string) {
  if (!fs.existsSync(dir)) return;
  const entries = fs.readdirSync(dir);
  for (const entry of entries) {
    const full = path.join(dir, entry);
    const stat = fs.lstatSync(full);
    if (stat.isDirectory()) rimrafDir(full);
    else fs.unlinkSync(full);
  }
  fs.rmdirSync(dir);
}

function ensureDir(dir: string) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

// Default content generator
function getDefaultContent(callsPerFile: number): string {
  const lines: string[] = [];
  lines.push('/* autogenerated stress fixture */');
  lines.push('export const noop = () => {};');
  for (let i = 0; i < callsPerFile; i++) {
    const fnName = `fn${i}`;
    lines.push(`function ${fnName}(){ return ${i}; }`);
  }
  for (let i = 0; i < callsPerFile; i++) {
    const fnName = `fn${i}`;
    lines.push(`${fnName}();`);
  }
  return lines.join('\n');
}

// Default expected matches calculator
function getDefaultExpectedMatches(callsPerFile: number, numberOfFiles: number): number {
  return callsPerFile * numberOfFiles;
}

interface TestRunnerOptions {
  numberOfFiles: number;
  callsPerFile: number;
  expression: string;
  interval?: number;
  getContent?: (callsPerFile: number) => string;
  getExpectedMatches?: (callsPerFile: number, numberOfFiles: number) => number;
  debugChunk?: (chunk: SearchResult[]) => void;
}

const testRunner = async ({
  numberOfFiles,
  callsPerFile,
  expression,
  interval = 10,
  getContent = getDefaultContent,
  getExpectedMatches = getDefaultExpectedMatches,
  debugChunk,
}: TestRunnerOptions): Promise<void> => {
  const content = getContent(callsPerFile);
  for (let i = 0; i < numberOfFiles; i++) {
    const f = path.join(STRESS_DIR, `file_${i}.ts`);
    fs.writeFileSync(f, content, 'utf-8');
  }
  const expectedMatches = getExpectedMatches(callsPerFile, numberOfFiles);
  const start = Date.now();
  let matches = 0;
  await search(
    expression,
    chunk => {
      debugChunk?.(chunk);
      matches += chunk.length;
    },
    { gitignore: true, directories: [STRESS_DIR], interval }
  );

  const durationMs = Date.now() - start;
  console.log(`Found ${matches} ${expression} in ${durationMs} ms across ${numberOfFiles} files.`);
  expect(matches).toBe(expectedMatches);
};

const TEST_CASES = [
  {
    name: 'Small stress test (10000 files, 50 calls each)',
    numberOfFiles: 10000,
    callsPerFile: 50,
    expression: 'CallExpression',
    skip: false,
  },
  {
    name: 'Custom test with Identifier search',
    numberOfFiles: 10,
    callsPerFile: 5,
    expression: 'Identifier',
    skip: false,
    getContent: (callsPerFile: number) => {
      const lines: string[] = [];
      lines.push('// identifier test content');
      for (let i = 0; i < callsPerFile; i++) {
        lines.push(`const var${i} = ${i};`);
      }
      return lines.join('\n');
    },
  },
  {
    name: 'Large stress test (100 files, 50000 calls each)',
    numberOfFiles: 100,
    callsPerFile: 50000,
    expression: 'CallExpression',
    skip: true,
  },
  {
    name: 'Variable declaration stress test',
    numberOfFiles: 50,
    callsPerFile: 100,
    expression: 'VariableDeclaration',
    skip: false,
    getContent: (callsPerFile: number) => {
      const lines: string[] = [];
      for (let i = 0; i < callsPerFile; i++) {
        lines.push(`let x${i} = ${i};`);
      }
      return lines.join('\n');
    },
  },
  {
    name: 'Function declaration stress test',
    numberOfFiles: 20,
    callsPerFile: 200,
    expression: 'FunctionDeclaration',
    skip: false,
    getContent: (callsPerFile: number) => {
      const lines: string[] = [];
      for (let i = 0; i < callsPerFile; i++) {
        lines.push(`function fn${i}() { return ${i}; }`);
      }
      return lines.join('\n');
    },
  },
  {
    name: 'Arrow function stress test',
    numberOfFiles: 10,
    callsPerFile: 300,
    expression: 'ArrowFunctionExpression',
    skip: false,
    getContent: (callsPerFile: number) => {
      const lines: string[] = [];
      for (let i = 0; i < callsPerFile; i++) {
        lines.push(`const arrow${i} = () => ${i};`);
      }
      return lines.join('\n');
    },
  },
  {
    name: 'Import declaration stress test',
    numberOfFiles: 5,
    callsPerFile: 100,
    expression: 'ImportDeclaration',
    skip: false,
    getContent: (callsPerFile: number) => {
      const lines: string[] = [];
      for (let i = 0; i < callsPerFile; i++) {
        lines.push(`import mod${i} from './mod${i}.js';`);
      }
      return lines.join('\n');
    },
  },
  {
    name: 'Mixed nodes (calls + identifiers)',
    numberOfFiles: 5,
    callsPerFile: 20,
    expression: 'Identifier',
    skip: false,
    getContent: (callsPerFile: number) => {
      const lines: string[] = [];
      for (let i = 0; i < callsPerFile; i++) {
        lines.push(`function f${i}()\n{ const v${i} = ${i};\nreturn v${i}; };\nf${i}();`);
      }
      return lines.join('\n');
    },
    getExpectedMatches: (callsPerFile: number, numberOfFiles: number) => {
      return numberOfFiles * callsPerFile * 4;
    },
  },
];

describe('Search Stress Tests', () => {
  jest.setTimeout(600000);
  beforeAll(() => {
    ensureDir(FIXTURES_DIR);
  });
  beforeEach(() => {
    ensureDir(STRESS_DIR);
  });
  afterEach(() => {
    rimrafDir(STRESS_DIR);
  });
  afterAll(cleanup);
  TEST_CASES.forEach(tc => {
    const runner = tc.skip ? it.skip : it;
    runner(tc.name, async () => {
      await testRunner(tc);
    });
  });
});
